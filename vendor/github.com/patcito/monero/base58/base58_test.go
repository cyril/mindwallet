package base58

import (
	"bytes"
	"hash/fnv"
	"io/ioutil"
	"testing"
	"time"
)

type uint8beTo64Test struct {
	n uint64
	b []byte
}

var uint8beTo64Tests = []*uint8beTo64Test{
	{0x0000000000000001, []byte{0x01}},
	{0x0000000000000102, []byte{0x01, 0x02}},
	{0x0000000000010203, []byte{0x01, 0x02, 0x03}},
	{0x0000000001020304, []byte{0x01, 0x02, 0x03, 0x04}},
	{0x0000000102030405, []byte{0x01, 0x02, 0x03, 0x04, 0x05}},
	{0x0000010203040506, []byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06}},
	{0x0001020304050607, []byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}},
	{0x0102030405060708, []byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}},
}

func TestUint8beTo64(t *testing.T) {
	for i, x := range uint8beTo64Tests {
		n := uint8beTo64(x.b)
		if n != x.n {
			t.Errorf("%d: want %x, got %x", i, x.n, n)
		}
	}
}

type encodeBlockTest struct {
	b []byte
	s string
}

var encodeBlockTests = []*encodeBlockTest{
	{[]byte{0x00}, "11"},
	{[]byte{0x39}, "1z"},
	{[]byte{0xFF}, "5Q"},

	{[]byte{0x00, 0x00}, "111"},
	{[]byte{0x00, 0x39}, "11z"},
	{[]byte{0x01, 0x00}, "15R"},
	{[]byte{0xFF, 0xFF}, "LUv"},

	{[]byte{0x00, 0x00, 0x00}, "11111"},
	{[]byte{0x00, 0x00, 0x39}, "1111z"},
	{[]byte{0x01, 0x00, 0x00}, "11LUw"},
	{[]byte{0xFF, 0xFF, 0xFF}, "2UzHL"},

	{[]byte{0x00, 0x00, 0x00, 0x39}, "11111z"},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF}, "7YXq9G"},
	{[]byte{0x00, 0x00, 0x00, 0x00, 0x39}, "111111z"},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, "VtB5VXc"},
	{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x39}, "11111111z"},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, "3CUsUpv9t"},
	{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39}, "111111111z"},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, "Ahg1opVcGW"},
	{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39}, "1111111111z"},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, "jpXCZedGfVQ"},

	{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, "11111111111"},
	{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}, "11111111112"},
	{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08}, "11111111119"},
	{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09}, "1111111111A"},
	{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A}, "11111111121"},
	{[]byte{0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, "1Ahg1opVcGW"},
	{[]byte{0x06, 0x15, 0x60, 0x13, 0x76, 0x28, 0x79, 0xF7}, "22222222222"},
	{[]byte{0x05, 0xE0, 0x22, 0xBA, 0x37, 0x4B, 0x2A, 0x00}, "1z111111111"},
}

func TestEncodeBlock(t *testing.T) {
	for _, x := range encodeBlockTests {
		out := make([]byte, len(x.s))
		encodeBlock(out, x.b)
		s := string(out)
		if s != x.s {
			t.Errorf("encodeBlock(%x): wanted %q, got %q", x.b, x.s, s)
		}
	}
}

func TestDecodeBlock(t *testing.T) {
	for _, x := range encodeBlockTests {
		b := make([]byte, len(x.b))
		decodeBlock(b, []byte(x.s))
		if !bytes.Equal(b, x.b) {
			t.Errorf("decodeBlock %s: want %x, got %x", x.s, x.b, b)
		}
	}
}

type encodeTest struct {
	s string
	b []byte
}

var encodeTests = []*encodeTest{
	{"11", []byte{0x00}},
	{"111", []byte{0x00, 0x00}},
	{"11111", []byte{0x00, 0x00, 0x00}},
	{"111111", []byte{0x00, 0x00, 0x00, 0x00}},
	{"1111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00}},
	{"111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"1111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"11111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"1111111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"11111111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"1111111111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"11111111111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"111111111111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"11111111111111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"111111111111111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"1111111111111111111111", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"22222222222VtB5VXc", []byte{0x06, 0x15, 0x60, 0x13, 0x76, 0x28, 0x79, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
}

func TestEncodedLen(t *testing.T) {
	for i, x := range encodeTests {
		l := EncodedLen(len(x.b))
		if l != len(x.s) {
			t.Errorf("EncodedLen %d: %s, want %d, got %d", i, x.s, len(x.s), l)
		}
	}
}

func TestEncode(t *testing.T) {
	for i, x := range encodeTests {
		out := make([]byte, len(x.s))
		Encode(out, x.b)
		s := string(out)
		if s != x.s {
			t.Errorf("encode %d: %x wanted %q, got %q", i, x.b, x.s, s)
		}
	}
}

func TestEncodeToString(t *testing.T) {
	for i, x := range encodeTests {
		s := EncodeToString(x.b)
		if s != x.s {
			t.Errorf("encode %d: wanted %q, got %q", i, x.s, s)
		}
	}
}

func TestDecodedLen(t *testing.T) {
	for i, x := range encodeTests {
		l := DecodedLen(len(x.s))
		if l != len(x.b) {
			t.Errorf("EncodedLen %d: %s, want %d, got %d", i, x.s, len(x.b), l)
		}
	}
}

func TestDecode(t *testing.T) {
	for i, x := range encodeTests {
		out := make([]byte, len(x.b))
		Decode(out, []byte(x.s))
		if !bytes.Equal(out, x.b) {
			t.Errorf("encode %d: %s wanted %x, got %x", i, x.s, x.b, out)
		}
	}
}

func TestDecodeString(t *testing.T) {
	for i, x := range encodeTests {
		b, _ := DecodeString(x.s)
		if !bytes.Equal(b, x.b) {
			t.Errorf("encode %d: wanted %x, got %x", i, x.b, b)
		}
	}
}

type encodeDecodeAddrTest struct {
	s   string
	tag uint64
	b   []byte
}

var encodeDecodeAddrTests = []*encodeDecodeAddrTest{
	{"21D35quxec71111111111111111111111111111111111111111111111111111111111111111111111111111116Q5tCH", 6,
		[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	},
	{"2Aui6ejTFscjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQVqegMoV", 6,
		[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
	{"1119XrkPuSmLzdHXgVgrZKjepg5hZAxffLzdHXgVgrZKjepg5hZAxffLzdHXgVgrZKjepg5hZAxffLzdHXgVgrZKVphZRvn", 0,
		[]byte{0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}},
	{"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111115TXfiA", 0,
		[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"PuT7GAdgbA83qvSEivPLYo11111111111111111111111111111111111111111111111111111111111111111111111111111169tWrH", 0x1122334455667788,
		[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"PuT7GAdgbA841d7FXjswpJjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQjpXCZedGfVQVq4LL1v", 0x1122334455667788,
		[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}},
	{"PuT7GAdgbA819VwdWVDP", 0x1122334455667788, []byte{0x11}},
	{"PuT7GAdgbA81efAfdCjPg", 0x1122334455667788, []byte{0x22, 0x22}},
	{"PuT7GAdgbA83sryEt3YC8Q", 0x1122334455667788, []byte{0x33, 0x33, 0x33}},
	{"PuT7GAdgbA83tWUuc54PFP3b", 0x1122334455667788, []byte{0x44, 0x44, 0x44, 0x44}},
	{"PuT7GAdgbA83u9zaKrtRKZ1J6", 0x1122334455667788, []byte{0x55, 0x55, 0x55, 0x55, 0x55}},
	{"PuT7GAdgbA83uoWF3eanGG1aRoG", 0x1122334455667788, []byte{0x66, 0x66, 0x66, 0x66, 0x66, 0x66}},
	{"PuT7GAdgbA83vT1umSHMYJ4oNVdu", 0x1122334455667788, []byte{0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77}},
	{"PuT7GAdgbA83w6XaVDyvpoGQBEWbB", 0x1122334455667788, []byte{0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88}},
	{"PuT7GAdgbA83wk3FD1gW7J2KVGofA1r", 0x1122334455667788, []byte{0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99}},
	{"15p2yAV", 0, []byte{}},
	{"FNQ3D6A", 0x7F, []byte{}},
	{"26k9QWweu", 0x80, []byte{}},
	{"3BzAD7n3y", 0xFF, []byte{}},
	{"11efCaY6UjG7JrxuB", 0, []byte{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77}},
	{"21rhHRT48LN4PriP9", 6, []byte{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77}},
}

func TestEncodeAddress(t *testing.T) {
	for i, x := range encodeDecodeAddrTests {
		s := encodeAddr(x.tag, x.b)
		if s != x.s {
			t.Errorf("%d: wanted %s, got %s", i, x.s, s)
		}
	}
}

func TestDecodeAddress(t *testing.T) {
	for i, x := range encodeDecodeAddrTests {
		tag, b := decodeAddr(x.s)
		if !bytes.Equal(b, x.b) {
			t.Errorf("%d: wanted %d:%x, got %d:%x", i, x.tag, x.b, tag, b)
		}
	}
}

func TestEncoderDecoder(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping test in short mode.")
	}
	h := fnv.New64()
	tmp, _ := time.Now().MarshalBinary()
	h.Write(tmp)
	tmp = h.Sum(tmp[:0])

	inFull := make([]byte, 1024)

	for p := 0; p < 1024; p += 64 {
		h.Sum(inFull[:p])
	}

	var (
		buf bytes.Buffer
		err error
	)

	for i := 0; i < 1024; i++ {
		in := inFull[:i]

		enc := NewEncoder(&buf)
		_, err = enc.Write(in)
		if err != nil {
			t.Fatal(err)
		}
		enc.Close()

		dec := NewDecoder(&buf)
		out, err := ioutil.ReadAll(dec)
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(in, out) {
			t.Fatalf("Wanted %x, got %x", in, out)
		}
	}
}

func BenchmarkEncoderDecoder(b *testing.B) {
	h := fnv.New64()
	tmp, _ := time.Now().MarshalBinary()
	h.Write(tmp)
	tmp = h.Sum(tmp[:0])
	var buf bytes.Buffer
	var err error
	b.ResetTimer()

	enc := NewEncoder(&buf)
	dec := NewDecoder(&buf)
	for i := 0; i < b.N; i++ {
		_, err = enc.Write(tmp)
		if err != nil {
			b.Fatal(err)
		}
		_, err = dec.Read(tmp)
		if err != nil {
			b.Fatal(err)
		}
	}
}
